//////////////////////////////////////////////////////////
// GENERATED BY FLUTTIFY. DO NOT EDIT IT.
//////////////////////////////////////////////////////////

package me.yohom.amap_map_fluttify.sub_handler;

import android.os.Bundle;
import android.util.Log;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import androidx.annotation.NonNull;
import io.flutter.embedding.engine.plugins.FlutterPlugin;
import io.flutter.plugin.common.BinaryMessenger;
import io.flutter.plugin.common.MethodCall;
import io.flutter.plugin.common.MethodChannel;
import io.flutter.plugin.common.PluginRegistry.Registrar;
import io.flutter.plugin.platform.PlatformViewRegistry;

import me.yohom.amap_map_fluttify.AmapMapFluttifyPlugin.Handler;

import static me.yohom.foundation_fluttify.FoundationFluttifyPluginKt.getEnableLog;
import static me.yohom.foundation_fluttify.FoundationFluttifyPluginKt.getHEAP;

@SuppressWarnings("ALL")
public class SubHandler20 {
    public static Map<String, Handler> getSubHandler(BinaryMessenger messenger) {
        return new HashMap<String, Handler>() {{
            // method
            put("com.amap.api.maps.AMapOptions::getCamera_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMapOptions ref = (com.amap.api.maps.AMapOptions) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.CameraPosition result;
                    try {
                        result = ref.getCamera();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMapOptions::getScaleControlsEnabled_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMapOptions ref = (com.amap.api.maps.AMapOptions) getHEAP().get(refId);
            
                    // invoke native method
                    boolean result;
                    try {
                        result = ref.getScaleControlsEnabled();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMapOptions::getZoomControlsEnabled_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMapOptions ref = (com.amap.api.maps.AMapOptions) getHEAP().get(refId);
            
                    // invoke native method
                    boolean result;
                    try {
                        result = ref.getZoomControlsEnabled();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMapOptions::getCompassEnabled_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMapOptions ref = (com.amap.api.maps.AMapOptions) getHEAP().get(refId);
            
                    // invoke native method
                    boolean result;
                    try {
                        result = ref.getCompassEnabled();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMapOptions::getScrollGesturesEnabled_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMapOptions ref = (com.amap.api.maps.AMapOptions) getHEAP().get(refId);
            
                    // invoke native method
                    boolean result;
                    try {
                        result = ref.getScrollGesturesEnabled();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMapOptions::getZoomGesturesEnabled_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMapOptions ref = (com.amap.api.maps.AMapOptions) getHEAP().get(refId);
            
                    // invoke native method
                    boolean result;
                    try {
                        result = ref.getZoomGesturesEnabled();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMapOptions::getTiltGesturesEnabled_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMapOptions ref = (com.amap.api.maps.AMapOptions) getHEAP().get(refId);
            
                    // invoke native method
                    boolean result;
                    try {
                        result = ref.getTiltGesturesEnabled();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMapOptions::getRotateGesturesEnabled_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMapOptions ref = (com.amap.api.maps.AMapOptions) getHEAP().get(refId);
            
                    // invoke native method
                    boolean result;
                    try {
                        result = ref.getRotateGesturesEnabled();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.OnMapLoadedListener::onMapLoaded_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.OnMapLoadedListener ref = (com.amap.api.maps.AMap.OnMapLoadedListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.onMapLoaded();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.OnMarkerClickListener::onMarkerClick_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.Marker var1 = (com.amap.api.maps.model.Marker) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.OnMarkerClickListener ref = (com.amap.api.maps.AMap.OnMarkerClickListener) getHEAP().get(refId);
            
                    // invoke native method
                    boolean result;
                    try {
                        result = ref.onMarkerClick(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.CoordinateConverter::from_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // enum arg
                    com.amap.api.maps.CoordinateConverter.CoordType var1 = com.amap.api.maps.CoordinateConverter.CoordType.values()[(int) ((Map<String, Object>) args).get("var1")];
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.CoordinateConverter ref = (com.amap.api.maps.CoordinateConverter) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.CoordinateConverter result;
                    try {
                        result = ref.from(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.CoordinateConverter::coord_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.LatLng var1 = (com.amap.api.maps.model.LatLng) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.CoordinateConverter ref = (com.amap.api.maps.CoordinateConverter) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.CoordinateConverter result;
                    try {
                        result = ref.coord(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.CoordinateConverter::convert_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.CoordinateConverter ref = (com.amap.api.maps.CoordinateConverter) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.LatLng result;
                    try {
                        result = ref.convert();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.CoordinateConverter::isAMapDataAvailable_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    double var0 = (double) ((Map<String, Object>) args).get("var0");
                    // jsonable arg
                    double var2 = (double) ((Map<String, Object>) args).get("var2");
            
                    // ref
            
            
                    // invoke native method
                    boolean result;
                    try {
                        result = com.amap.api.maps.CoordinateConverter.isAMapDataAvailable(var0, var2);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.InfoWindowAdapter::getInfoWindow_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.Marker var1 = (com.amap.api.maps.model.Marker) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.InfoWindowAdapter ref = (com.amap.api.maps.AMap.InfoWindowAdapter) getHEAP().get(refId);
            
                    // invoke native method
                    android.view.View result;
                    try {
                        result = ref.getInfoWindow(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.InfoWindowAdapter::getInfoContents_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.Marker var1 = (com.amap.api.maps.model.Marker) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.InfoWindowAdapter ref = (com.amap.api.maps.AMap.InfoWindowAdapter) getHEAP().get(refId);
            
                    // invoke native method
                    android.view.View result;
                    try {
                        result = ref.getInfoContents(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.OnMyLocationChangeListener::onMyLocationChange_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    android.location.Location var1 = (android.location.Location) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.OnMyLocationChangeListener ref = (com.amap.api.maps.AMap.OnMyLocationChangeListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.onMyLocationChange(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.onMapPrintScreenListener::onMapPrint_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    android.graphics.drawable.Drawable var1 = (android.graphics.drawable.Drawable) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.onMapPrintScreenListener ref = (com.amap.api.maps.AMap.onMapPrintScreenListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.onMapPrint(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.ImageInfoWindowAdapter::getInfoWindowUpdateTime_batch", (argsBatch, methodResult) -> {
                List<Long> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.ImageInfoWindowAdapter ref = (com.amap.api.maps.AMap.ImageInfoWindowAdapter) getHEAP().get(refId);
            
                    // invoke native method
                    long result;
                    try {
                        result = ref.getInfoWindowUpdateTime();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    long jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.OnMarkerDragListener::onMarkerDragStart_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.Marker var1 = (com.amap.api.maps.model.Marker) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.OnMarkerDragListener ref = (com.amap.api.maps.AMap.OnMarkerDragListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.onMarkerDragStart(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.OnMarkerDragListener::onMarkerDrag_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.Marker var1 = (com.amap.api.maps.model.Marker) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.OnMarkerDragListener ref = (com.amap.api.maps.AMap.OnMarkerDragListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.onMarkerDrag(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.OnMarkerDragListener::onMarkerDragEnd_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.Marker var1 = (com.amap.api.maps.model.Marker) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.OnMarkerDragListener ref = (com.amap.api.maps.AMap.OnMarkerDragListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.onMarkerDragEnd(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.SpatialRelationUtil::calShortestDistancePoint__com_amap_api_maps_model_LatLng__com_amap_api_maps_model_LatLng__double__double_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // list arg
                    List<Integer> var0RefIdList = (List<Integer>) ((Map<String, Object>) args).get("var0");
                    List<com.amap.api.maps.model.LatLng> var0 = new ArrayList<>();
                    for (int refId : var0RefIdList) {
                        var0.add((com.amap.api.maps.model.LatLng) getHEAP().get(refId));
                    }
                    // ref arg
                    com.amap.api.maps.model.LatLng var1 = (com.amap.api.maps.model.LatLng) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
                    // jsonable arg
                    Double var2 = (Double) ((Map<String, Object>) args).get("var2");
                    // jsonable arg
                    double var3 = (double) ((Map<String, Object>) args).get("var3");
            
                    // ref
            
            
                    // invoke native method
                    android.util.Pair<Integer,com.amap.api.maps.model.LatLng> result;
                    try {
                        result = com.amap.api.maps.utils.SpatialRelationUtil.calShortestDistancePoint(new ArrayList(var0), var1, new Double(var2).floatValue(), var3);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.SpatialRelationUtil::calShortestDistancePoint__com_amap_api_maps_model_LatLng__com_amap_api_maps_model_LatLng_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // list arg
                    List<Integer> var0RefIdList = (List<Integer>) ((Map<String, Object>) args).get("var0");
                    List<com.amap.api.maps.model.LatLng> var0 = new ArrayList<>();
                    for (int refId : var0RefIdList) {
                        var0.add((com.amap.api.maps.model.LatLng) getHEAP().get(refId));
                    }
                    // ref arg
                    com.amap.api.maps.model.LatLng var1 = (com.amap.api.maps.model.LatLng) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
            
            
                    // invoke native method
                    android.util.Pair<Integer,com.amap.api.maps.model.LatLng> result;
                    try {
                        result = com.amap.api.maps.utils.SpatialRelationUtil.calShortestDistancePoint(new ArrayList(var0), var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.SpatialRelationUtil::calShortestDistancePoint__com_autonavi_amap_mapcore_DPoint__com_autonavi_amap_mapcore_DPoint_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // list arg
                    List<Integer> var0RefIdList = (List<Integer>) ((Map<String, Object>) args).get("var0");
                    List<com.autonavi.amap.mapcore.DPoint> var0 = new ArrayList<>();
                    for (int refId : var0RefIdList) {
                        var0.add((com.autonavi.amap.mapcore.DPoint) getHEAP().get(refId));
                    }
                    // ref arg
                    com.autonavi.amap.mapcore.DPoint var1 = (com.autonavi.amap.mapcore.DPoint) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
            
            
                    // invoke native method
                    android.util.Pair<Integer,com.autonavi.amap.mapcore.DPoint> result;
                    try {
                        result = com.amap.api.maps.utils.SpatialRelationUtil.calShortestDistancePoint(new ArrayList(var0), var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.SpatialRelationUtil::calShortestDistancePoint__com_autonavi_amap_mapcore_DPoint__com_autonavi_amap_mapcore_DPoint__double_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // list arg
                    List<Integer> var0RefIdList = (List<Integer>) ((Map<String, Object>) args).get("var0");
                    List<com.autonavi.amap.mapcore.DPoint> var0 = new ArrayList<>();
                    for (int refId : var0RefIdList) {
                        var0.add((com.autonavi.amap.mapcore.DPoint) getHEAP().get(refId));
                    }
                    // ref arg
                    com.autonavi.amap.mapcore.DPoint var1 = (com.autonavi.amap.mapcore.DPoint) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
                    // jsonable arg
                    Double var2 = (Double) ((Map<String, Object>) args).get("var2");
            
                    // ref
            
            
                    // invoke native method
                    android.util.Pair<Integer,com.autonavi.amap.mapcore.DPoint> result;
                    try {
                        result = com.amap.api.maps.utils.SpatialRelationUtil.calShortestDistancePoint(new ArrayList(var0), var1, new Double(var2).floatValue());
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker.MoveListener::move_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    double var1 = (double) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker.MoveListener ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker.MoveListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.move(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.MovingPointOverlay::setPoints_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // list arg
                    List<Integer> var1RefIdList = (List<Integer>) ((Map<String, Object>) args).get("var1");
                    List<com.amap.api.maps.model.LatLng> var1 = new ArrayList<>();
                    for (int refId : var1RefIdList) {
                        var1.add((com.amap.api.maps.model.LatLng) getHEAP().get(refId));
                    }
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.MovingPointOverlay ref = (com.amap.api.maps.utils.overlay.MovingPointOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setPoints(new ArrayList(var1));
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.MovingPointOverlay::resetIndex_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.MovingPointOverlay ref = (com.amap.api.maps.utils.overlay.MovingPointOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.resetIndex();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.MovingPointOverlay::setTotalDuration_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.MovingPointOverlay ref = (com.amap.api.maps.utils.overlay.MovingPointOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setTotalDuration(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.MovingPointOverlay::startSmoothMove_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.MovingPointOverlay ref = (com.amap.api.maps.utils.overlay.MovingPointOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.startSmoothMove();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.MovingPointOverlay::stopMove_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.MovingPointOverlay ref = (com.amap.api.maps.utils.overlay.MovingPointOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.stopMove();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.MovingPointOverlay::getObject_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.MovingPointOverlay ref = (com.amap.api.maps.utils.overlay.MovingPointOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.BasePointOverlay result;
                    try {
                        result = ref.getObject();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.MovingPointOverlay::getPosition_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.MovingPointOverlay ref = (com.amap.api.maps.utils.overlay.MovingPointOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.LatLng result;
                    try {
                        result = ref.getPosition();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.MovingPointOverlay::getIndex_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.MovingPointOverlay ref = (com.amap.api.maps.utils.overlay.MovingPointOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    int result;
                    try {
                        result = ref.getIndex();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    int jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.MovingPointOverlay::destroy_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.MovingPointOverlay ref = (com.amap.api.maps.utils.overlay.MovingPointOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.destroy();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.MovingPointOverlay::removeMarker_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.MovingPointOverlay ref = (com.amap.api.maps.utils.overlay.MovingPointOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.removeMarker();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.MovingPointOverlay::setPosition_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.LatLng var1 = (com.amap.api.maps.model.LatLng) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.MovingPointOverlay ref = (com.amap.api.maps.utils.overlay.MovingPointOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setPosition(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.MovingPointOverlay::setRotate_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    Double var1 = (Double) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.MovingPointOverlay ref = (com.amap.api.maps.utils.overlay.MovingPointOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setRotate(new Double(var1).floatValue());
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.MovingPointOverlay::setVisible_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    boolean var1 = (boolean) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.MovingPointOverlay ref = (com.amap.api.maps.utils.overlay.MovingPointOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setVisible(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.MovingPointOverlay.MoveListener::move_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    double var1 = (double) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.MovingPointOverlay.MoveListener ref = (com.amap.api.maps.utils.overlay.MovingPointOverlay.MoveListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.move(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker::setPoints_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // list arg
                    List<Integer> var1RefIdList = (List<Integer>) ((Map<String, Object>) args).get("var1");
                    List<com.amap.api.maps.model.LatLng> var1 = new ArrayList<>();
                    for (int refId : var1RefIdList) {
                        var1.add((com.amap.api.maps.model.LatLng) getHEAP().get(refId));
                    }
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setPoints(new ArrayList(var1));
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker::setTotalDuration_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setTotalDuration(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker::startSmoothMove_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.startSmoothMove();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker::stopMove_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.stopMove();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker::getMarker_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.Marker result;
                    try {
                        result = ref.getMarker();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker::getPosition_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.LatLng result;
                    try {
                        result = ref.getPosition();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker::getIndex_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker) getHEAP().get(refId);
            
                    // invoke native method
                    int result;
                    try {
                        result = ref.getIndex();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    int jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker::resetIndex_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.resetIndex();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker::destroy_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.destroy();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker::removeMarker_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.removeMarker();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker::setPosition_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.LatLng var1 = (com.amap.api.maps.model.LatLng) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setPosition(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker::setDescriptor_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.BitmapDescriptor var1 = (com.amap.api.maps.model.BitmapDescriptor) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setDescriptor(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker::setRotate_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    Double var1 = (Double) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setRotate(new Double(var1).floatValue());
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.utils.overlay.SmoothMoveMarker::setVisible_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    boolean var1 = (boolean) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.utils.overlay.SmoothMoveMarker ref = (com.amap.api.maps.utils.overlay.SmoothMoveMarker) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setVisible(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.LocationSource.OnLocationChangedListener::onLocationChanged_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    android.location.Location var1 = (android.location.Location) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.LocationSource.OnLocationChangedListener ref = (com.amap.api.maps.LocationSource.OnLocationChangedListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.onLocationChanged(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::initialize_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    android.content.Context var0 = (android.content.Context) getHEAP().get((int) ((Map<String, Object>) args).get("var0"));
            
                    // ref
            
            
                    // invoke native method
                    try {
                        com.amap.api.maps.MapsInitializer.initialize(var0);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::setNetWorkEnable_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    boolean var0 = (boolean) ((Map<String, Object>) args).get("var0");
            
                    // ref
            
            
                    // invoke native method
                    try {
                        com.amap.api.maps.MapsInitializer.setNetWorkEnable(var0);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::getNetWorkEnable_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
            
            
                    // invoke native method
                    boolean result;
                    try {
                        result = com.amap.api.maps.MapsInitializer.getNetWorkEnable();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::setApiKey_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var0 = (String) ((Map<String, Object>) args).get("var0");
            
                    // ref
            
            
                    // invoke native method
                    try {
                        com.amap.api.maps.MapsInitializer.setApiKey(var0);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::getVersion_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
            
            
                    // invoke native method
                    String result;
                    try {
                        result = com.amap.api.maps.MapsInitializer.getVersion();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::loadWorldGridMap_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    boolean var0 = (boolean) ((Map<String, Object>) args).get("var0");
            
                    // ref
            
            
                    // invoke native method
                    try {
                        com.amap.api.maps.MapsInitializer.loadWorldGridMap(var0);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::isLoadWorldGridMap_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
            
            
                    // invoke native method
                    boolean result;
                    try {
                        result = com.amap.api.maps.MapsInitializer.isLoadWorldGridMap();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::setBuildingHeight_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var0 = (int) ((Map<String, Object>) args).get("var0");
            
                    // ref
            
            
                    // invoke native method
                    try {
                        com.amap.api.maps.MapsInitializer.setBuildingHeight(var0);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::setDownloadCoordinateConvertLibrary_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    boolean var0 = (boolean) ((Map<String, Object>) args).get("var0");
            
                    // ref
            
            
                    // invoke native method
                    try {
                        com.amap.api.maps.MapsInitializer.setDownloadCoordinateConvertLibrary(var0);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::isDownloadCoordinateConvertLibrary_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
            
            
                    // invoke native method
                    boolean result;
                    try {
                        result = com.amap.api.maps.MapsInitializer.isDownloadCoordinateConvertLibrary();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::setHost_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var0 = (String) ((Map<String, Object>) args).get("var0");
            
                    // ref
            
            
                    // invoke native method
                    try {
                        com.amap.api.maps.MapsInitializer.setHost(var0);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::setProtocol_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var0 = (int) ((Map<String, Object>) args).get("var0");
            
                    // ref
            
            
                    // invoke native method
                    try {
                        com.amap.api.maps.MapsInitializer.setProtocol(var0);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::getProtocol_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
            
            
                    // invoke native method
                    int result;
                    try {
                        result = com.amap.api.maps.MapsInitializer.getProtocol();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    int jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::closeTileOverlay_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    boolean var0 = (boolean) ((Map<String, Object>) args).get("var0");
            
                    // ref
            
            
                    // invoke native method
                    try {
                        com.amap.api.maps.MapsInitializer.closeTileOverlay(var0);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.MapsInitializer::isTileOverlayClosed_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
            
            
                    // invoke native method
                    boolean result;
                    try {
                        result = com.amap.api.maps.MapsInitializer.isTileOverlayClosed();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapProvince::getUrl_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapProvince ref = (com.amap.api.maps.offlinemap.OfflineMapProvince) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getUrl();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapProvince::setUrl_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapProvince ref = (com.amap.api.maps.offlinemap.OfflineMapProvince) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setUrl(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapProvince::getState_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapProvince ref = (com.amap.api.maps.offlinemap.OfflineMapProvince) getHEAP().get(refId);
            
                    // invoke native method
                    int result;
                    try {
                        result = ref.getState();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    int jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapProvince::setState_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapProvince ref = (com.amap.api.maps.offlinemap.OfflineMapProvince) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setState(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapProvince::getSize_batch", (argsBatch, methodResult) -> {
                List<Long> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapProvince ref = (com.amap.api.maps.offlinemap.OfflineMapProvince) getHEAP().get(refId);
            
                    // invoke native method
                    long result;
                    try {
                        result = ref.getSize();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    long jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapProvince::setSize_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapProvince ref = (com.amap.api.maps.offlinemap.OfflineMapProvince) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setSize(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapProvince::getVersion_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapProvince ref = (com.amap.api.maps.offlinemap.OfflineMapProvince) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getVersion();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapProvince::setVersion_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapProvince ref = (com.amap.api.maps.offlinemap.OfflineMapProvince) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setVersion(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapProvince::getcompleteCode_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapProvince ref = (com.amap.api.maps.offlinemap.OfflineMapProvince) getHEAP().get(refId);
            
                    // invoke native method
                    int result;
                    try {
                        result = ref.getcompleteCode();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    int jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapProvince::setCompleteCode_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapProvince ref = (com.amap.api.maps.offlinemap.OfflineMapProvince) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setCompleteCode(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapProvince::getCityList_batch", (argsBatch, methodResult) -> {
                List<List<Integer>> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapProvince ref = (com.amap.api.maps.offlinemap.OfflineMapProvince) getHEAP().get(refId);
            
                    // invoke native method
                    List<com.amap.api.maps.offlinemap.OfflineMapCity> result;
                    try {
                        result = ref.getCityList();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    List<Integer> jsonableResult = null;
                    if (result != null) {
                        jsonableResult = new ArrayList<>();
                        for (com.amap.api.maps.offlinemap.OfflineMapCity item : result) {
                            getHEAP().put(item.hashCode(), item);
                            jsonableResult.add(item.hashCode());
                        }
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapProvince::getDownloadedCityList_batch", (argsBatch, methodResult) -> {
                List<List<Integer>> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapProvince ref = (com.amap.api.maps.offlinemap.OfflineMapProvince) getHEAP().get(refId);
            
                    // invoke native method
                    List<com.amap.api.maps.offlinemap.OfflineMapCity> result;
                    try {
                        result = ref.getDownloadedCityList();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    List<Integer> jsonableResult = null;
                    if (result != null) {
                        jsonableResult = new ArrayList<>();
                        for (com.amap.api.maps.offlinemap.OfflineMapCity item : result) {
                            getHEAP().put(item.hashCode(), item);
                            jsonableResult.add(item.hashCode());
                        }
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapProvince::setCityList_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // list arg
                    List<Integer> var1RefIdList = (List<Integer>) ((Map<String, Object>) args).get("var1");
                    List<com.amap.api.maps.offlinemap.OfflineMapCity> var1 = new ArrayList<>();
                    for (int refId : var1RefIdList) {
                        var1.add((com.amap.api.maps.offlinemap.OfflineMapCity) getHEAP().get(refId));
                    }
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapProvince ref = (com.amap.api.maps.offlinemap.OfflineMapProvince) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setCityList(new ArrayList(var1));
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager.OfflineMapDownloadListener::onDownload_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
                    // jsonable arg
                    int var2 = (int) ((Map<String, Object>) args).get("var2");
                    // jsonable arg
                    String var3 = (String) ((Map<String, Object>) args).get("var3");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager.OfflineMapDownloadListener ref = (com.amap.api.maps.offlinemap.OfflineMapManager.OfflineMapDownloadListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.onDownload(var1, var2, var3);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager.OfflineMapDownloadListener::onCheckUpdate_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    boolean var1 = (boolean) ((Map<String, Object>) args).get("var1");
                    // jsonable arg
                    String var2 = (String) ((Map<String, Object>) args).get("var2");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager.OfflineMapDownloadListener ref = (com.amap.api.maps.offlinemap.OfflineMapManager.OfflineMapDownloadListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.onCheckUpdate(var1, var2);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager.OfflineMapDownloadListener::onRemove_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    boolean var1 = (boolean) ((Map<String, Object>) args).get("var1");
                    // jsonable arg
                    String var2 = (String) ((Map<String, Object>) args).get("var2");
                    // jsonable arg
                    String var3 = (String) ((Map<String, Object>) args).get("var3");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager.OfflineMapDownloadListener ref = (com.amap.api.maps.offlinemap.OfflineMapManager.OfflineMapDownloadListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.onRemove(var1, var2, var3);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.DownloadProgressView::setProgress_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.DownloadProgressView ref = (com.amap.api.maps.offlinemap.DownloadProgressView) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setProgress(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.Province::getProvinceName_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.Province ref = (com.amap.api.maps.offlinemap.Province) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getProvinceName();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.Province::getJianpin_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.Province ref = (com.amap.api.maps.offlinemap.Province) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getJianpin();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.Province::getPinyin_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.Province ref = (com.amap.api.maps.offlinemap.Province) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getPinyin();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.Province::setProvinceName_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.Province ref = (com.amap.api.maps.offlinemap.Province) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setProvinceName(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.Province::setJianpin_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.Province ref = (com.amap.api.maps.offlinemap.Province) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setJianpin(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.Province::setPinyin_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.Province ref = (com.amap.api.maps.offlinemap.Province) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setPinyin(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.Province::setProvinceCode_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.Province ref = (com.amap.api.maps.offlinemap.Province) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setProvinceCode(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.Province::getProvinceCode_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.Province ref = (com.amap.api.maps.offlinemap.Province) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getProvinceCode();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::downloadByCityCode_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.downloadByCityCode(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::downloadByCityName_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.downloadByCityName(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::downloadByProvinceName_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.downloadByProvinceName(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::remove_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.remove(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::getOfflineMapProvinceList_batch", (argsBatch, methodResult) -> {
                List<List<Integer>> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    List<com.amap.api.maps.offlinemap.OfflineMapProvince> result;
                    try {
                        result = ref.getOfflineMapProvinceList();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    List<Integer> jsonableResult = null;
                    if (result != null) {
                        jsonableResult = new ArrayList<>();
                        for (com.amap.api.maps.offlinemap.OfflineMapProvince item : result) {
                            getHEAP().put(item.hashCode(), item);
                            jsonableResult.add(item.hashCode());
                        }
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::getItemByCityCode_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.offlinemap.OfflineMapCity result;
                    try {
                        result = ref.getItemByCityCode(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::getItemByCityName_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.offlinemap.OfflineMapCity result;
                    try {
                        result = ref.getItemByCityName(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::getItemByProvinceName_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.offlinemap.OfflineMapProvince result;
                    try {
                        result = ref.getItemByProvinceName(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::getOfflineMapCityList_batch", (argsBatch, methodResult) -> {
                List<List<Integer>> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    List<com.amap.api.maps.offlinemap.OfflineMapCity> result;
                    try {
                        result = ref.getOfflineMapCityList();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    List<Integer> jsonableResult = null;
                    if (result != null) {
                        jsonableResult = new ArrayList<>();
                        for (com.amap.api.maps.offlinemap.OfflineMapCity item : result) {
                            getHEAP().put(item.hashCode(), item);
                            jsonableResult.add(item.hashCode());
                        }
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::getDownloadingCityList_batch", (argsBatch, methodResult) -> {
                List<List<Integer>> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    List<com.amap.api.maps.offlinemap.OfflineMapCity> result;
                    try {
                        result = ref.getDownloadingCityList();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    List<Integer> jsonableResult = null;
                    if (result != null) {
                        jsonableResult = new ArrayList<>();
                        for (com.amap.api.maps.offlinemap.OfflineMapCity item : result) {
                            getHEAP().put(item.hashCode(), item);
                            jsonableResult.add(item.hashCode());
                        }
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::getDownloadingProvinceList_batch", (argsBatch, methodResult) -> {
                List<List<Integer>> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    List<com.amap.api.maps.offlinemap.OfflineMapProvince> result;
                    try {
                        result = ref.getDownloadingProvinceList();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    List<Integer> jsonableResult = null;
                    if (result != null) {
                        jsonableResult = new ArrayList<>();
                        for (com.amap.api.maps.offlinemap.OfflineMapProvince item : result) {
                            getHEAP().put(item.hashCode(), item);
                            jsonableResult.add(item.hashCode());
                        }
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::getDownloadOfflineMapCityList_batch", (argsBatch, methodResult) -> {
                List<List<Integer>> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    List<com.amap.api.maps.offlinemap.OfflineMapCity> result;
                    try {
                        result = ref.getDownloadOfflineMapCityList();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    List<Integer> jsonableResult = null;
                    if (result != null) {
                        jsonableResult = new ArrayList<>();
                        for (com.amap.api.maps.offlinemap.OfflineMapCity item : result) {
                            getHEAP().put(item.hashCode(), item);
                            jsonableResult.add(item.hashCode());
                        }
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::getDownloadOfflineMapProvinceList_batch", (argsBatch, methodResult) -> {
                List<List<Integer>> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    List<com.amap.api.maps.offlinemap.OfflineMapProvince> result;
                    try {
                        result = ref.getDownloadOfflineMapProvinceList();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    List<Integer> jsonableResult = null;
                    if (result != null) {
                        jsonableResult = new ArrayList<>();
                        for (com.amap.api.maps.offlinemap.OfflineMapProvince item : result) {
                            getHEAP().put(item.hashCode(), item);
                            jsonableResult.add(item.hashCode());
                        }
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::updateOfflineCityByCode_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.updateOfflineCityByCode(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::updateOfflineCityByName_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.updateOfflineCityByName(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::updateOfflineMapProvinceByName_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.updateOfflineMapProvinceByName(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::restart_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.restart();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::stop_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.stop();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::pause_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.pause();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager::destroy_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager ref = (com.amap.api.maps.offlinemap.OfflineMapManager) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.destroy();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapCity::getUrl_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapCity ref = (com.amap.api.maps.offlinemap.OfflineMapCity) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getUrl();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapCity::setUrl_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapCity ref = (com.amap.api.maps.offlinemap.OfflineMapCity) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setUrl(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapCity::getSize_batch", (argsBatch, methodResult) -> {
                List<Long> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapCity ref = (com.amap.api.maps.offlinemap.OfflineMapCity) getHEAP().get(refId);
            
                    // invoke native method
                    long result;
                    try {
                        result = ref.getSize();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    long jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapCity::setSize_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapCity ref = (com.amap.api.maps.offlinemap.OfflineMapCity) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setSize(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapCity::getState_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapCity ref = (com.amap.api.maps.offlinemap.OfflineMapCity) getHEAP().get(refId);
            
                    // invoke native method
                    int result;
                    try {
                        result = ref.getState();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    int jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapCity::setState_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapCity ref = (com.amap.api.maps.offlinemap.OfflineMapCity) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setState(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapCity::getVersion_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapCity ref = (com.amap.api.maps.offlinemap.OfflineMapCity) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getVersion();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapCity::setVersion_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapCity ref = (com.amap.api.maps.offlinemap.OfflineMapCity) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setVersion(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapCity::getcompleteCode_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapCity ref = (com.amap.api.maps.offlinemap.OfflineMapCity) getHEAP().get(refId);
            
                    // invoke native method
                    int result;
                    try {
                        result = ref.getcompleteCode();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    int jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapCity::setCompleteCode_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapCity ref = (com.amap.api.maps.offlinemap.OfflineMapCity) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setCompleteCode(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.City::setCity_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.City ref = (com.amap.api.maps.offlinemap.City) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setCity(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.City::getCity_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.City ref = (com.amap.api.maps.offlinemap.City) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getCity();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.City::setCode_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.City ref = (com.amap.api.maps.offlinemap.City) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setCode(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.City::getCode_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.City ref = (com.amap.api.maps.offlinemap.City) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getCode();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.City::getJianpin_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.City ref = (com.amap.api.maps.offlinemap.City) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getJianpin();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.City::setJianpin_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.City ref = (com.amap.api.maps.offlinemap.City) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setJianpin(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.City::getPinyin_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.City ref = (com.amap.api.maps.offlinemap.City) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getPinyin();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.City::setPinyin_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.City ref = (com.amap.api.maps.offlinemap.City) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setPinyin(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.City::getAdcode_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.City ref = (com.amap.api.maps.offlinemap.City) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getAdcode();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.City::setAdcode_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    String var1 = (String) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.City ref = (com.amap.api.maps.offlinemap.City) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setAdcode(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.offlinemap.OfflineMapManager.OfflineLoadedListener::onVerifyComplete_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.offlinemap.OfflineMapManager.OfflineLoadedListener ref = (com.amap.api.maps.offlinemap.OfflineMapManager.OfflineLoadedListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.onVerifyComplete();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.OnIndoorBuildingActiveListener::OnIndoorBuilding_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.IndoorBuildingInfo var1 = (com.amap.api.maps.model.IndoorBuildingInfo) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.OnIndoorBuildingActiveListener ref = (com.amap.api.maps.AMap.OnIndoorBuildingActiveListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.OnIndoorBuilding(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.OnMapTouchListener::onTouch_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    android.view.MotionEvent var1 = (android.view.MotionEvent) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.OnMapTouchListener ref = (com.amap.api.maps.AMap.OnMapTouchListener) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.onTouch(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.Projection::fromScreenLocation_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    android.graphics.Point var1 = (android.graphics.Point) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.Projection ref = (com.amap.api.maps.Projection) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.LatLng result;
                    try {
                        result = ref.fromScreenLocation(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.Projection::toScreenLocation_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.LatLng var1 = (com.amap.api.maps.model.LatLng) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.Projection ref = (com.amap.api.maps.Projection) getHEAP().get(refId);
            
                    // invoke native method
                    android.graphics.Point result;
                    try {
                        result = ref.toScreenLocation(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.Projection::toOpenGLLocation_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.LatLng var1 = (com.amap.api.maps.model.LatLng) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.Projection ref = (com.amap.api.maps.Projection) getHEAP().get(refId);
            
                    // invoke native method
                    android.graphics.PointF result;
                    try {
                        result = ref.toOpenGLLocation(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.Projection::toOpenGLWidth_batch", (argsBatch, methodResult) -> {
                List<Float> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.Projection ref = (com.amap.api.maps.Projection) getHEAP().get(refId);
            
                    // invoke native method
                    float result;
                    try {
                        result = ref.toOpenGLWidth(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    float jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.Projection::getVisibleRegion_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.Projection ref = (com.amap.api.maps.Projection) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.VisibleRegion result;
                    try {
                        result = ref.getVisibleRegion();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.Projection::fromBoundsToTile_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.LatLngBounds var1 = (com.amap.api.maps.model.LatLngBounds) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
                    // jsonable arg
                    int var2 = (int) ((Map<String, Object>) args).get("var2");
                    // jsonable arg
                    int var3 = (int) ((Map<String, Object>) args).get("var3");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.Projection ref = (com.amap.api.maps.Projection) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.TileProjection result;
                    try {
                        result = ref.fromBoundsToTile(var1, var2, var3);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.Projection::getMapBounds_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.LatLng var1 = (com.amap.api.maps.model.LatLng) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
                    // jsonable arg
                    Double var2 = (Double) ((Map<String, Object>) args).get("var2");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.Projection ref = (com.amap.api.maps.Projection) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.LatLngBounds result;
                    try {
                        result = ref.getMapBounds(var1, new Double(var2).floatValue());
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.Projection::getCameraInfo_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.Projection ref = (com.amap.api.maps.Projection) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.AMapCameraInfo result;
                    try {
                        result = ref.getCameraInfo();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.MultiPositionInfoWindowAdapter::getInfoWindowClick_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.Marker var1 = (com.amap.api.maps.model.Marker) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.MultiPositionInfoWindowAdapter ref = (com.amap.api.maps.AMap.MultiPositionInfoWindowAdapter) getHEAP().get(refId);
            
                    // invoke native method
                    android.view.View result;
                    try {
                        result = ref.getInfoWindowClick(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.MultiPositionInfoWindowAdapter::getOverturnInfoWindow_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.Marker var1 = (com.amap.api.maps.model.Marker) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.MultiPositionInfoWindowAdapter ref = (com.amap.api.maps.AMap.MultiPositionInfoWindowAdapter) getHEAP().get(refId);
            
                    // invoke native method
                    android.view.View result;
                    try {
                        result = ref.getOverturnInfoWindow(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.AMap.MultiPositionInfoWindowAdapter::getOverturnInfoWindowClick_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.Marker var1 = (com.amap.api.maps.model.Marker) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.AMap.MultiPositionInfoWindowAdapter ref = (com.amap.api.maps.AMap.MultiPositionInfoWindowAdapter) getHEAP().get(refId);
            
                    // invoke native method
                    android.view.View result;
                    try {
                        result = ref.getOverturnInfoWindowClick(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::remove_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.remove();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::getId_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getId();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::setPoints_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // list arg
                    List<Integer> var1RefIdList = (List<Integer>) ((Map<String, Object>) args).get("var1");
                    List<com.amap.api.maps.model.LatLng> var1 = new ArrayList<>();
                    for (int refId : var1RefIdList) {
                        var1.add((com.amap.api.maps.model.LatLng) getHEAP().get(refId));
                    }
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setPoints(new ArrayList(var1));
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::getPoints_batch", (argsBatch, methodResult) -> {
                List<List<Integer>> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    List<com.amap.api.maps.model.LatLng> result;
                    try {
                        result = ref.getPoints();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    List<Integer> jsonableResult = null;
                    if (result != null) {
                        jsonableResult = new ArrayList<>();
                        for (com.amap.api.maps.model.LatLng item : result) {
                            getHEAP().put(item.hashCode(), item);
                            jsonableResult.add(item.hashCode());
                        }
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::setHoleOptions_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // list arg
                    List<Integer> var1RefIdList = (List<Integer>) ((Map<String, Object>) args).get("var1");
                    List<com.amap.api.maps.model.BaseHoleOptions> var1 = new ArrayList<>();
                    for (int refId : var1RefIdList) {
                        var1.add((com.amap.api.maps.model.BaseHoleOptions) getHEAP().get(refId));
                    }
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setHoleOptions(new ArrayList(var1));
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::getHoleOptions_batch", (argsBatch, methodResult) -> {
                List<List<Integer>> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    List<com.amap.api.maps.model.BaseHoleOptions> result;
                    try {
                        result = ref.getHoleOptions();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    List<Integer> jsonableResult = null;
                    if (result != null) {
                        jsonableResult = new ArrayList<>();
                        for (com.amap.api.maps.model.BaseHoleOptions item : result) {
                            getHEAP().put(item.hashCode(), item);
                            jsonableResult.add(item.hashCode());
                        }
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::setStrokeWidth_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    Double var1 = (Double) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setStrokeWidth(new Double(var1).floatValue());
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::getStrokeWidth_batch", (argsBatch, methodResult) -> {
                List<Float> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    float result;
                    try {
                        result = ref.getStrokeWidth();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    float jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::setStrokeColor_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setStrokeColor(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::getStrokeColor_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    int result;
                    try {
                        result = ref.getStrokeColor();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    int jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::setFillColor_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setFillColor(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::getFillColor_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    int result;
                    try {
                        result = ref.getFillColor();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    int jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::setZIndex_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    Double var1 = (Double) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setZIndex(new Double(var1).floatValue());
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::getZIndex_batch", (argsBatch, methodResult) -> {
                List<Float> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    float result;
                    try {
                        result = ref.getZIndex();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    float jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::setVisible_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    boolean var1 = (boolean) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.setVisible(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::isVisible_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    boolean result;
                    try {
                        result = ref.isVisible();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Polygon::contains_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.LatLng var1 = (com.amap.api.maps.model.LatLng) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Polygon ref = (com.amap.api.maps.model.Polygon) getHEAP().get(refId);
            
                    // invoke native method
                    boolean result;
                    try {
                        result = ref.contains(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.BitmapDescriptor::getId_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.BitmapDescriptor ref = (com.amap.api.maps.model.BitmapDescriptor) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getId();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.BitmapDescriptor::clone_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.BitmapDescriptor ref = (com.amap.api.maps.model.BitmapDescriptor) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.BitmapDescriptor result;
                    try {
                        result = ref.clone();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.BitmapDescriptor::getBitmap_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.BitmapDescriptor ref = (com.amap.api.maps.model.BitmapDescriptor) getHEAP().get(refId);
            
                    // invoke native method
                    android.graphics.Bitmap result;
                    try {
                        result = ref.getBitmap();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.BitmapDescriptor::getWidth_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.BitmapDescriptor ref = (com.amap.api.maps.model.BitmapDescriptor) getHEAP().get(refId);
            
                    // invoke native method
                    int result;
                    try {
                        result = ref.getWidth();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    int jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.BitmapDescriptor::getHeight_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.BitmapDescriptor ref = (com.amap.api.maps.model.BitmapDescriptor) getHEAP().get(refId);
            
                    // invoke native method
                    int result;
                    try {
                        result = ref.getHeight();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    int jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.PolygonHoleOptions::addAll_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // list arg
                    List<Integer> var1RefIdList = (List<Integer>) ((Map<String, Object>) args).get("var1");
                    List<com.amap.api.maps.model.LatLng> var1 = new ArrayList<>();
                    for (int refId : var1RefIdList) {
                        var1.add((com.amap.api.maps.model.LatLng) getHEAP().get(refId));
                    }
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.PolygonHoleOptions ref = (com.amap.api.maps.model.PolygonHoleOptions) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.PolygonHoleOptions result;
                    try {
                        result = ref.addAll(new ArrayList(var1));
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.PolygonHoleOptions::getPoints_batch", (argsBatch, methodResult) -> {
                List<List<Integer>> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.PolygonHoleOptions ref = (com.amap.api.maps.model.PolygonHoleOptions) getHEAP().get(refId);
            
                    // invoke native method
                    List<com.amap.api.maps.model.LatLng> result;
                    try {
                        result = ref.getPoints();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    List<Integer> jsonableResult = null;
                    if (result != null) {
                        jsonableResult = new ArrayList<>();
                        for (com.amap.api.maps.model.LatLng item : result) {
                            getHEAP().put(item.hashCode(), item);
                            jsonableResult.add(item.hashCode());
                        }
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Poi::getName_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Poi ref = (com.amap.api.maps.model.Poi) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getName();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Poi::getCoordinate_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Poi ref = (com.amap.api.maps.model.Poi) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.LatLng result;
                    try {
                        result = ref.getCoordinate();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.Poi::getPoiId_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.Poi ref = (com.amap.api.maps.model.Poi) getHEAP().get(refId);
            
                    // invoke native method
                    String result;
                    try {
                        result = ref.getPoiId();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::myLocationIcon_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.BitmapDescriptor var1 = (com.amap.api.maps.model.BitmapDescriptor) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.MyLocationStyle result;
                    try {
                        result = ref.myLocationIcon(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::anchor_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    Double var1 = (Double) ((Map<String, Object>) args).get("var1");
                    // jsonable arg
                    Double var2 = (Double) ((Map<String, Object>) args).get("var2");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.MyLocationStyle result;
                    try {
                        result = ref.anchor(new Double(var1).floatValue(), new Double(var2).floatValue());
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::radiusFillColor_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.MyLocationStyle result;
                    try {
                        result = ref.radiusFillColor(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::strokeColor_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.MyLocationStyle result;
                    try {
                        result = ref.strokeColor(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::strokeWidth_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    Double var1 = (Double) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.MyLocationStyle result;
                    try {
                        result = ref.strokeWidth(new Double(var1).floatValue());
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::myLocationType_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.MyLocationStyle result;
                    try {
                        result = ref.myLocationType(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::interval_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    int var1 = (int) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.MyLocationStyle result;
                    try {
                        result = ref.interval(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::showMyLocation_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    boolean var1 = (boolean) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.MyLocationStyle result;
                    try {
                        result = ref.showMyLocation(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::getMyLocationIcon_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.BitmapDescriptor result;
                    try {
                        result = ref.getMyLocationIcon();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::getAnchorU_batch", (argsBatch, methodResult) -> {
                List<Float> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    float result;
                    try {
                        result = ref.getAnchorU();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    float jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::getAnchorV_batch", (argsBatch, methodResult) -> {
                List<Float> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    float result;
                    try {
                        result = ref.getAnchorV();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    float jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::getRadiusFillColor_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    int result;
                    try {
                        result = ref.getRadiusFillColor();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    int jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::getStrokeColor_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    int result;
                    try {
                        result = ref.getStrokeColor();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    int jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::getStrokeWidth_batch", (argsBatch, methodResult) -> {
                List<Float> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    float result;
                    try {
                        result = ref.getStrokeWidth();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    float jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::getMyLocationType_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    int result;
                    try {
                        result = ref.getMyLocationType();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    int jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::getInterval_batch", (argsBatch, methodResult) -> {
                List<Long> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    long result;
                    try {
                        result = ref.getInterval();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    long jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.MyLocationStyle::isMyLocationShowing_batch", (argsBatch, methodResult) -> {
                List<Boolean> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.MyLocationStyle ref = (com.amap.api.maps.model.MyLocationStyle) getHEAP().get(refId);
            
                    // invoke native method
                    boolean result;
                    try {
                        result = ref.isMyLocationShowing();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    boolean jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.RouteOverlay::removeRouteName_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.RouteOverlay ref = (com.amap.api.maps.model.RouteOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.removeRouteName();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.RouteOverlay::remove_batch", (argsBatch, methodResult) -> {
                List<String> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.RouteOverlay ref = (com.amap.api.maps.model.RouteOverlay) getHEAP().get(refId);
            
                    // invoke native method
                    try {
                        ref.remove();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    String jsonableResult = "success";
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.CircleHoleOptions::center_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // ref arg
                    com.amap.api.maps.model.LatLng var1 = (com.amap.api.maps.model.LatLng) getHEAP().get((int) ((Map<String, Object>) args).get("var1"));
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.CircleHoleOptions ref = (com.amap.api.maps.model.CircleHoleOptions) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.CircleHoleOptions result;
                    try {
                        result = ref.center(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.CircleHoleOptions::radius_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
                    // jsonable arg
                    double var1 = (double) ((Map<String, Object>) args).get("var1");
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.CircleHoleOptions ref = (com.amap.api.maps.model.CircleHoleOptions) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.CircleHoleOptions result;
                    try {
                        result = ref.radius(var1);
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.CircleHoleOptions::getCenter_batch", (argsBatch, methodResult) -> {
                List<Integer> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.CircleHoleOptions ref = (com.amap.api.maps.model.CircleHoleOptions) getHEAP().get(refId);
            
                    // invoke native method
                    com.amap.api.maps.model.LatLng result;
                    try {
                        result = ref.getCenter();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    Integer jsonableResult = null;
                    if (result != null) {
                        jsonableResult = result.hashCode();
                        getHEAP().put(jsonableResult, result);
                    }
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
            // method
            put("com.amap.api.maps.model.CircleHoleOptions::getRadius_batch", (argsBatch, methodResult) -> {
                List<Double> resultList = new ArrayList<>();
            
                for (int i = 0; i < ((List<Map<String, Object>>) argsBatch).size(); i++) {
                    Map<String, Object> args = ((List<Map<String, Object>>) argsBatch).get(i);
            
                    // args
            
            
                    // ref
                    int refId = (int) ((Map<String, Object>) args).get("refId");
                    com.amap.api.maps.model.CircleHoleOptions ref = (com.amap.api.maps.model.CircleHoleOptions) getHEAP().get(refId);
            
                    // invoke native method
                    double result;
                    try {
                        result = ref.getRadius();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                        if (getEnableLog()) {
                            Log.d("Current HEAP: ", getHEAP().toString());
                        }
                        methodResult.error(throwable.getMessage(), null, null);
                        return;
                    }
            
                    // convert result to jsonable result
                    double jsonableResult = result;
            
                    resultList.add(jsonableResult);
                }
            
                methodResult.success(resultList);
            });
        }};
    }
}
